#mysql

#### Service层

* 连接器：负责和客户端建立连接、获取权限、维持和管理l连接
* 查询缓存：执行过的语句会以key-value的形式存在内存中，一般不建议使用缓存，更新操作导致缓存失效
* 分析器：对sql进行词法分析，判断是否满足sql语法
* 优化器：在sql执行的时候，如果有多个索引的时候决定用哪个索引，多表关联的时候决定表的连接顺序
* 执行器：根据表定义的引擎使用用引擎提供的接口，如果查询不走索引，判断每一行是否满足条件，组装结果集返回。



####存储引擎

* 存储数据，提供接口，在表创建的时候指定，默认是InnoDB



## 数据更新日志

####redolog、binlog



索引总结

1.索引的作用：提高数据查询效率
2.常见索引模型：哈希表、有序数组、搜索树
3.哈希表：键 - 值(key - value)。
4.哈希思路：把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置
5.哈希冲突的处理办法：链表
6.哈希表适用场景：只有等值查询的场景
7.有序数组：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N))
8.有序数组查询效率高，更新效率低
9.有序数组的适用场景：静态存储引擎。
10.二叉搜索树：每个节点的左儿子小于父节点，父节点又小于右儿子
11.二叉搜索树：查询时间复杂度O(log(N))，更新时间复杂度O(log(N))
12.数据库存储大多不适用二叉树，因为树高过高，会适用N叉树
13.InnoDB中的索引模型：B+Tree
14.索引类型：主键索引、非主键索引
主键索引的叶子节点存的是整行的数据(聚簇索引)，非主键索引的叶子节点内容是主键的值(二级索引)
15.主键索引和普通索引的区别：主键索引只要搜索ID这个B+Tree即可拿到数据。普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(**回表**)
16.一个数据页满了，按照B+Tree算法，新增加一个数据页，叫做页分裂，会导致性能下降。空间利用率降低大概50%。当相邻的两个数据页利用率很低的时候会做数据页合并，合并的过程是分裂过程的逆过程。
17.从性能和存储空间方面考量，自增主键往往是更合理的选择。



**避免回表**

查询具有索引的字段，select id from T where k between 3 and 5,需要查询id的值，id的值已经存在于k索引树上，可以直接得到结果避免回表，这种称为覆盖索引，覆盖索引可以减少树的搜索次数，提高性能，是一种常用的优化手段。



**基于覆盖索引衍生的问题**

在市民信息表上有必要将身份证号、姓名作为组合索引吗？

如果有一个场景是根据身份证号查询姓名，就有必要使用组合索引，这样可以用到覆盖索引，提高查询效率



**索引的重建**

* 为什么重建：由于插入、删除数据导致页分裂，数据页存在空洞，重建索引将数据重新排列，页面的利用率更高，索引更加紧凑、节约空间。
* 重建索引k的做法是合理的但是重建主键，无论是删除还是重建，都会将整个表重建，连着两个语句，第一个就白做了，可以用alter table T engine=InnoDB
* 案例：今天这个 alter table T engine=InnoDB 让我想到了我们线上的一个表, 记录日志用的, 会定期删除过早之前的数据. 最后这个表实际内容的大小才10G, 而他的索引却有30G. 在阿里云控制面板上看,就是占了40G空间. 这可花的是真金白银啊.后来了解到是 InnoDB 这种引擎导致的,虽然删除了表的部分记录,但是它的索引还在, 并未释放.只能是重新建表才能重建索引.如果当时看到了这个专栏,把这个语句拿来用,就可以省下不少钱了

```sql
//查询表数据、索引大小
SELECT TABLE_NAME,DATA_LENGTH,INDEX_LENGTH,TABLE_ROWS FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA='legend' AND TABLE_NAME='legend_order_info';
```





