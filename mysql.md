#mysql

#### Service层

* 连接器：负责和客户端建立连接、获取权限、维持和管理l连接
* 查询缓存：执行过的语句会以key-value的形式存在内存中，一般不建议使用缓存，更新操作导致缓存失效
* 分析器：对s
* 
* 优化器：在sql执行的时候，如果有多个索引的时候决定用哪个索引，多表关联的时候决定表的连接顺序
* 执行器：根据表定义的引擎使用用引擎提供的接口，如果查询不走索引，判断每一行是否满足条件，组装结果集返回。



####存储引擎

* 存储数据，提供接口，在表创建的时候指定，默认是InnoDB



## 数据更新日志

####redolog、binlog

**索引的本质是数据结构**

聚集索引：数据包含索引文件

非聚集索引：数据文件、索引文件分开



索引总结

1.索引的作用：提高数据查询效率
2.常见索引模型：哈希表、有序数组、搜索树
3.哈希表：键 - 值(key - value)。
4.哈希思路：把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置
5.哈希冲突的处理办法：链表
6.哈希表适用场景：只有等值查询的场景
7.有序数组：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N))
8.有序数组查询效率高，更新效率低
9.有序数组的适用场景：静态存储引擎。
10.二叉搜索树：每个节点的左儿子小于父节点，父节点又小于右儿子
11.二叉搜索树：查询时间复杂度O(log(N))，更新时间复杂度O(log(N))
12.数据库存储大多不适用二叉树，因为树高过高，会适用N叉树
13.InnoDB中的索引模型：B+Tree
14.索引类型：主键索引、非主键索引
主键索引的叶子节点存的是整行的数据(聚簇索引)，非主键索引的叶子节点内容是主键的值(二级索引)
15.主键索引和普通索引的区别：主键索引只要搜索ID这个B+Tree即可拿到数据。普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(**回表**)
16.一个数据页满了，按照B+Tree算法，新增加一个数据页，叫做页分裂，会导致性能下降。空间利用率降低大概50%。当相邻的两个数据页利用率很低的时候会做数据页合并，合并的过程是分裂过程的逆过程。
17.从性能和存储空间方面考量，自增主键往往是更合理的选择。







**避免回表**

查询具有索引的字段，select id from T where k between 3 and 5,需要查询id的值，id的值已经存在于k索引树上，可以直接得到结果避免回表，这种称为覆盖索引，覆盖索引可以减少树的搜索次数，提高性能，是一种常用的优化手段。



**基于覆盖索引衍生的问题**

在市民信息表上有必要将身份证号、姓名作为组合索引吗？

如果有一个场景是根据身份证号查询姓名，就有必要使用组合索引，这样可以用到覆盖索引，提高查询效率



**索引的重建**

* 为什么重建：由于插入、删除数据导致页分裂，数据页存在空洞，重建索引将数据重新排列，页面的利用率更高，索引更加紧凑、节约空间。
* 重建索引k的做法是合理的但是重建主键，无论是删除还是重建，都会将整个表重建，连着两个语句，第一个就白做了，可以用alter table T engine=InnoDB
* 案例：今天这个 alter table T engine=InnoDB 让我想到了我们线上的一个表, 记录日志用的, 会定期删除过早之前的数据. 最后这个表实际内容的大小才10G, 而他的索引却有30G. 在阿里云控制面板上看,就是占了40G空间. 这可花的是真金白银啊.后来了解到是 InnoDB 这种引擎导致的,虽然删除了表的部分记录,但是它的索引还在, 并未释放.只能是重新建表才能重建索引.如果当时看到了这个专栏,把这个语句拿来用,就可以省下不少钱了

```sql
//查询表数据、索引大小
SELECT TABLE_NAME,DATA_LENGTH,INDEX_LENGTH,TABLE_ROWS FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA='legend' AND TABLE_NAME='legend_order_info';
```



####数据库锁对性能的影响

**1、两阶段锁**

InnoDB事务中，行锁在需要的时候才被加上，但并不是不需要了就立刻释放，而是要等到事务结束了才释放，这就是两阶段锁协议。知道了这个设定，**如果我们事务中需要多个行锁，把最有可能造成冲突的放在最后**

**2、死锁和死锁检测**

当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，会导致几个线程都进入无限等待的状态，称为死锁。

![image-20190118112904401](/Users/shchenbang/Library/Application Support/typora-user-images/image-20190118112904401.png)



出现这种情况，有两种策略

* 进入等待，直到超时，超时时间可以通过innodb_lock_wait_timeout设置
* 发起死锁检测，发现死锁后回滚死锁链路中的一个事务，让其他事务继续执行，将参赛innob_deadlock_detect设置on，开启这个逻辑

正常情况下我们会选择第二个策略，但是如果有1000个线程并发更新一行，那么每个线程都进行死锁检测这个就是1000*1000=100W。这对**cpu资源的消耗**是非常大的

解决思路：

* 确认业务不会出现死锁，关闭死锁检测的设置（不推荐）
* 控制并发度：a、直接在客户端做并发控制；b、修改mysql源码，基本思路对于相同行的更新，在进入引擎之前排队，这样InnoDB内部避免大量死锁检测。
* 将一行改成逻辑上多行减少锁的冲突，如修改账户的案例，例如可以分成10条记录，账户总额等于10条记录的总额，每次增加账户的操作随机选择一条来操心，那么冲突的概率就变成了1/10（这种设计需要特殊处理，如退款时，账户变成0的时候需要考虑）



#### 优化器的逻辑

​       选择索引就是优化器的工作，优化器选择索引是找到一个最优的执行方案，并用最小的代价去执行语句，在sql执行过程中，扫描行数是影响执行代价的因素之一。扫描行数越少，意味着访问磁盘的次数越少，消耗的CPU资源越少，当然扫描行数不是唯一的判断标准，优化器还会根据是否使用临时表、是否排序等因数综合判断。

​      **扫描行的判断**

​      mysql执行之前无法精确的知道满足条件的记录数，而是根据统计信息来估算记录数。

​      这个统计信息就是“区分度”。显然一个索引上不同的值越多，索引的区分度越好。而一个索引上不同值的个数，我们称为“基数”，也就是基数越大，索引区分度越好。可以使用show index 方法看到索引的基数。

​     **force index 强制指定索引**



  #### 字符串上建索引

```
mysql> alter table SUser add index index1(email);
或
mysql> alter table SUser add index index2(email(6));
```

email(6)是前缀索引，每个邮箱字段只取前六个字段，索引在内存所占的空间更小，这也是前缀索引的优势

但是前缀索引可能会导致查询语句读数据的次数变多。

**如果定义好合适的长度既可以节省空间，又不用额外的增加太多的查询成本**



#####前缀对覆盖索引的影响

```sql
1、select id,email from SUser where email='zhangssxyz@xxx.com';
2、select id,name,email from SUser where email='zhangssxyz@xxx.com';
```

如果使用index1，可以利用覆盖索引直接返回查询结果就好了，如果使用index2的话必须通过id索引再去判断一下email的值



##### 其他方式

对于类似邮箱的字段可以使用前缀索引，但是如果前缀区分度不够的情况，应该如何处理

如身份证前面6位是地址

* 倒叙存储 reverse
* 使用hash字段：通过新增一个字段



####mysql有哪些索引
#####数据结构角度：
* B+树索引
* Hash索引： 哈希索引基于哈希表实现，只有精确索引所有列的查询才有效，每一行数据存储引擎都会计算一个hash码，所有的hash码都存在索引中，同时保存的还有指向每个数据的指针
  限制： 不能部分匹配
  ​      不能使用hash索引排序
  ​      只支持等着比较，例如使用=，IN( )和<=> 对于WHERE price>100并不能加速查询。
  ​      访问hash索引的速度非常快，如果出现hash冲突的话要进行逐行比较，hash冲突的话维护的成本很高



* R-Tree索引

#####物理存储角度：

* 聚集索引：聚集索引表示表中存储的数据按照索引的顺序存储，检索效率比非聚集索引高，但对数据更新影响较大；
* 非聚集索引：非聚集索引表示数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置，非聚集索引检索效率比聚集索引低，但对数据更新影响较小

#####逻辑角度：
* 主键索引
* 普通索引
* 组合索引
* 唯一索引

加索引的好处和坏处(为什么加索引会比较快)

加索引后导致数据插入效率变慢，如何提高插入效率
如果业务运行可以把索引干掉
采用异步写入、可以使用队列

