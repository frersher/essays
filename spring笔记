spring事物传播模式：
1、required：业务方法运行时，如果有事物加入这个事物,否者新建事物
2、not_support：声明方法不需要事物，容器默认不开启事物，如果方法在一个事物中被调用，该事物挂起，调用结束，原事物恢复
3、requirenew：不管是否存在事物，都会发起一个新事物，如果方法已经运行在事物中，则原事物挂起创建新事物。
4、mandatory(强制的):只能在一个已存在的事物中执行，不能发起自己的事物，如果在没有事物的环境下别调用，抛异常
5、support：在事物范围内调用，成为该事物的一部分。在事物外被调用，则在没有事物的环境下被调用。
6、never：不能再事物中被调用，否者报错
7、nested：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。


事物的隔离级别
1、Serializable ：最严格的级别，事务串行执行，资源消耗最大；
2、REPEATABLE READ ：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但是带来了更多的性能损失。
3、READ COMMITTED :大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”。该级别适用于大多数系统。
4、Read Uncommitted ：保证了读取过程中不会读取到非法数据。


@Transactional失效
1、如果方法不是public会失效
2、如果异常是check默认也不会滚，如果想check异常回归，注解上面写明异常类型
3、数据库引擎要支持事物，如mysql 注意如果是myisam事物是不起作用的
4、是否开启了对注解的解析
    <tx:annotation-driven transaction-manager="transactionManager" proxy-target-class="true"/>
5、spring 是否扫描到这个包

