代理模式
对目标对象提供另外一种访问方式，即通过代理对象访问目标对象，这样做的好处在于，在不修改目标对象的前提下实现对目标对象的扩展，在实际开发者可以通过不修改他人代码的基础上达到修改和扩展的目的

     静态代理：定义一个接口或父类，目标类和代理类需要实现同一个接口或继承同一个父类
     缺点：一旦修改接口，目标对象、代理对象都要维护

     动态代理：代理对象不需要实现接口、代理对象的生成是利用JDK的API动态的在内存中构建的，也叫jdk代理、接口代理

     cglib代理：静态代理、动态代理都需要目标对象实现接口，但有时候对象是没有实现接口的，所以可以通过对目标对象子类的方式实现代理，这种方法叫cglib代理，在spring的AOP中cglib代理实现拦截




适配器模式：因为某些需求导致老的接口不适用，在不修改原有接口的情况下，将接口转化为可用接口。就是保留现有现有类的服务，满足客户的需求
           类适配器模式：当我们要访问接口A中没有我们想要的方法，在B接口中发现了，但是有不能改变对A接口的访问，所有需要定义一个P匹配器，P实现A接口继承B接口的实现类BB 这样的话可以即不改变对A接口的使用也可以用到B接口的发方法。

           对象适配器模式：和上面的场景一下，定义一个适配器P之后，P实现A接口，在P中定义一个B类型的变量C，通过构造函数对C赋值，在接口A的实现方法中通过C调用B的方法来实现。

           接口适配器模式：接口中有很多方法，但是只需要使用其中的一个或一部分，需要通过抽象类继承接口，再通过实现类来继承抽象类，可以只实现需要的方法。

https://www.cnblogs.com/V1haoge/p/6479118.html           



几种模式的区别：
适配器模式，一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起，做法是将自己的接口包裹在一个已存在的类中。
装饰器模式，原有的不能满足现有的需求，对原有的进行增强。
代理模式，同一个类而去调用另一个类的方法，不对这个方法进行直接操作
代理和装饰：代理主要是代码的隔离、装饰一般是加强功能    
     

工厂模式
  简单工厂模式：客户端不用关心对象创建的过程，只要告诉工厂创建什么，工厂会负责不同对象的创建
  工厂方法模式：是简单工厂模式的延伸。在工厂方法模式中，核心工厂不再负责工厂创建，将具体的创建工作交给子类完成。也就是核心工厂类仅仅提供创建接口，具体实现方法交给继承它的子类去完成。当我们的系统需要增加其他新的对象时，我们只需要添加一个具体的产品和它的创建工厂即可，不需要对原工厂进行任何修改，这样很好地符合了“开闭原则”。


