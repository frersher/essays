**java的垃圾回收**
通过可达性算法分析，通过一系列的GC root的节点作为起始节点向下查找，搜索所经过的路径被称为"引用链"，当一个对象到Gc root没经过任何引用链则证明此对象是不可用的

通过可达性算法存在的问题：
逐个检查比较耗时，在可达性分析的时候必须保证一致性，停掉所有执行的java线程。即使是在号称
（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。



**在java中，可作为GC Roots的对象有：**

- 虚拟机栈（栈帧中的本地变量表）中引用的对象

- 方法区中的类静态属性引用的对象

- 方法区中常量引用的对象

- 本地方法栈中JNI（即一般说的Native方法）中引用的对象；




**再谈引用**
JDK1.2 将对象引用分为4种：强引用、软引用、弱引用、虚引用



**jvm内存结构**

* 主要分为三块：堆、栈、方法区

  1、堆：是内存中最大的一块，主要分为新生代、老年代。新生代又分为Eden空间、From Survivor空间、To Survivor空间，比例按照8:1:1；创建的对象直接放在堆上，被所有的线程共享
  如果堆上没有内存完成实例分配，且堆内存无法扩展时，则会出现OutOfMemoryError
  2、方法区：用于存储已被虚拟机加载的类的信息、常量、静态变量
  3、程序计数器：是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器

  4、栈：每个线程创建时都会创建一个虚拟机栈，内部保存着栈帧当前运行Java方法的地址

  堆和方法区是线程共享的，其他的时是线程独有的

  ![image-20190121214233006](/Users/cb/Library/Application Support/typora-user-images/image-20190121214233006.png)

**对象的内部布局**

* 对象头
     a)存储对象自身运行时的数据，hashCode、GC分代年龄、锁状态标志、持有锁的线程等
     b)类型指针，虚拟机通过类型指针确定是哪个对象的实例
* 实例数据：对象正常存储的有效信息，也就是对象中各种类型的字段内容
* 对齐填充：不是必然的，没有特殊的含义，仅仅是占位符的作用



**垃圾回收算法**

* 标记-清除算法
     原理简单，但是效率不高、导致回收后的空间不连续，如果放入较大对象时，还需要进行另一次垃圾回收
* 复制算法
  ​    将内存分为两块，每次只是用其中的一块，这一块快用完的时候，把存活的对象复制到另外一块，然后把一用完的空间回收掉。
* 标记-整理算法
  ​    和标记清理算法类似，只是后面不是直接回收，而是将存活的对象移到一端，然后进行回收边界以外的区域(老年代)
* 分代收集算法
  ​    一般把java堆分为新生代、老年代，新生代存活的对象较少使用复制算法，老年代使用复制算法、标记-清除算法。

 **堆内存的划分**

* 新生代
     a.Eden区
     b.survivor区

*  老年代   
   虚拟机给每个对象定义一个对象年龄，如果Eden的对象经过一次GC还存活，并且可以被survivor容纳的话，将对象移到survivor，并将年龄设为1，对象在survivor中每经过一次GC年龄加一，到一定阶段对象会被放入老年代，默认是15，可以通过jvm参数修改
    如果survivor中相同年龄的对象占survivor空间的一半，年龄大于或等于这个年龄的对象也可以进入老年代


回收策略（避免频繁的fullGc）
1.大多数情况下对象分配在Eden中，如果Eden空间不足时，虚拟机会发起一次Minor Gc
2.新生代Gc(Minor Gc)：在新生代发生的垃圾回收动作，因为java对象大多数有朝生夕灭的规律，所以Minor Gc发生的非常频繁，而且速度也很快
3.老年代Gc(Major Gc（清理老年代）、Full Gc（ 是清理整个堆空间—包括年轻代和老年代）)：Full Gc 往往会伴随着一次Minor Gc，当Minor Gc产生时会判断
  a.老年代最大可用的连续空间是否大于新手代所有对象所占的空间  成立 进行Minor Gc
  b.a不成立 查看虚拟机参数是否允许担保失败 如果不允许Full Gc 如果允许，继续检查老年代最大连续可用空间是否大于历次晋升到老年代对象的平均大小 
  c.b成立 进行Minor Gc 如果不成立进行Full Gc



垃圾回收器
新生代
serial：单线程收集器，每次执行来及回收时需要停掉其他所有的工作线程，直到它收集完成。（默认的新生代回收器，简单高效）
parNew：是serial多线程版本
Parallel Scavenge:精确的控制吞吐量（应用场景：高吞吐量为目标，减少垃圾回收的时间）

老年代
serial old：是serial的老年代版本，针对老年代，采用标记整理算法
parallel old ：是parallel的老年代版本，采用标记整理算法
CMS：基于标记清理算法（产生碎片），并发收集，停顿时间短。

整堆回收
G1：并发与并行，可以充分利用多cpu，可以独立管理整个Gc堆，不需要与其他回收器组合使用。

内存泄漏
不使用的对象内存没有别回收
1、如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露（全局变量的生命周期长于局部变量），尽量定义作用域小的变量、手动赋值null


内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；
内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。
memory leak会最终会导致out of memory！

JVM 设置参数 -XX:+HeapDumpOnOutOfMemoryError。让 JVM 碰到 OOM 的时候，输出 dump 信息。



虚拟机的类加载机制
类的生命周期氛围7个阶段：
加载：通过类的全限定名找到类的二进制字节流，再将字节流代表的静态存储结构转化为方法区的运行时数据结构，最后在内存中生成class对象

验证：简单的说就是保证你的class文件中包含的信息符合虚拟机要求

准备：Java 中有「类变量」和「类成员变量」两种，为类变量分配内存并设置初始值注意：public static int value=123;这行代码在准备阶段 value的初始值为0，准备阶段不执行任何java代码，只有在初始化时才把value的值赋为123

解析：虚拟机将常量池内的符号引用替换为直接引用的过程

初始化：初始化阶段是执行类构造器方法的过程
(家政被解除)



    双亲委派模型：(定音战旗）
          启动类加载器
    
          扩展类加载器
    
          应用程序类加载器(系统类加载器)
    
    自定义类加载器     自定义类加载器

如上：类加载器之间的关系称为双亲委派模型（除了顶层 启动类加载器之外其他的类加载器都有自己的父类加载器）

双亲委派模式的工作流程：如果类加载器收到了类加载的请求，首先会被这个请求委派给自己的父类，每层都是如此，最终请求会到最顶层的启动类加载器，如果父类无法完成这个加载请求(搜索的范围内没有这个类)，子类才会尝试着自己完成这个请求。

好处：java类随着它的类加载器一起有着累层级关系，比如object无论哪个类加载它，最终都会委托到启动类加载器，所以object在各种的类加载器中都是同一个类。所以双亲委派机制保证类java程序运行的稳定性。






HashMap的线程不安全问题

synchronized

Thread.yield()
CPU从一个线程转移到另一个线程

Executor：一个接口，其定义了一个接收Runnable对象的方法executor，其方法签名为executor(Runnable command),

ExecutorService：是一个比Executor使用更广泛的子类接口，其提供了生命周期管理的方法，以及可跟踪一个或多个异步任务执行状况返回Future的方法

AbstractExecutorService：ExecutorService执行方法的默认实现

ScheduledExecutorService：一个可定时调度任务的接口

ScheduledThreadPoolExecutor：ScheduledExecutorService的实现，一个可定时调度任务的线程池

ThreadPoolExecutor：线程池，可以通过调用Executors以下静态工厂方法来创建线程池并返回一个ExecutorService对象：

CachedThreadPool：为每一个任务创建线程
FixedThreadPool：一次性的预执行代替了高昂的线程分配，同时也限制了线程的数量
SingleThreadPool：相当于线程数为1的FixThreadPool


线程的优先级
可以用getPriority、setPriority查看和设置

HashMap
数组+链表
初始化是通过initailCapacity：16和laodFactor：0.75创建默认的链表数据组
为啥要使用负载因子:
这样做的目的是为了使每个桶(链表)包含的数量较少，最好是一个，这样查找的速度会很快，哈希碰撞会对hashMap的性能带来灾难性的影响。如果多个hashCode()的值落到同一个桶内的时候，这些值是存储到一个链表中的。最坏的情况下，所有的key都映射到同一个桶中，这样hashmap就退化成了一个链表——查找时间从O(1)到O(n)

目前hashMap解决hash冲突的方式是链地址法，还有使用比较广泛的是开放地址发，这种方法是指在冲突的时候立即计算出后补地址，直到有空地址为止





java8对hashMap的优化
1、java8以前在通过key的hashCode计算下标位置的时候，进行四次扰动计算，jdk1.8编程一扰动，低16位和高16位进行异或运算。提高了取模运算的速度
2、引入红黑树





cglib动态代理


java8新特性
lambda表达式是一段可以传递的代码，
lambda表达式实际上就是代码块的传递的实现
Java虚拟机（JVM）的新特性
PermGen空间被移除了，取而代之的是Metaspace（JEP 122）

Socked
是基于TCP/IP的流套接字，它是一种稳定的通信协议


Mybatis的缓存
一级缓存
mybatis默认开启一级缓存，一级缓存是在SqlSession 层面进行缓存的。即，同一个SqlSession ，多次调用同一个Mapper和同一个方法的同一个参数，只会进行一次数据库查询，然后把数据缓存到缓冲中，以后直接先从缓存中取出数据，不会直接去查数据库。

二级缓存
文件配置了cacheEnabled=true时，就会开启二级缓存，二级缓存是mapper级别的，也就说不同的sqlsession使用同一个mapper查询是，查询到的数据可能是另一个sqlsession做相同操作留下的缓存
之前说一级缓存是Executor执行操作时会去PerpetualCache中的HashMap中根据cacheKey查询缓存。
而二级缓存的是这样的：SqlSession对象创建Executor对象时，会对Executor对象加上一个装饰者：CachingExecutor，然后将操作数据库的任务交给CachingExecutor，此时CachingExecutor会查找二级缓存是否有需要的数据，如果没有则将任务交给Executor对象。
这里使用的装饰器模式，CachingExecutor包装了Executor接口，
由此刻见，如果你配置了二级缓存，那么查询数据的顺序应该为：二级缓存→一级缓存→数据库



NIO和IO的区别

IO：比如我们为了读取一个TCP连接的数据，在没有数据的情况下线程被挂起，直到数据到达才会被唤醒，那么该线程在数据到达这段时间占用着系统资源无所作为，造成资源的浪费。



IO面向流、NIO面向buffer(缓冲区)
IO的各种流是阻塞的，每次读取一个或多个字节，直至读取所有字节，没有缓存在任何地方，因此不能前后移动流中的数据。一个线程读、写必须等待读、写完。

NIO处理略有不同，将数据读到缓冲区中，需要时可在缓冲区移动增加了处理的灵活性，NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。

NIO核心组成
a) Channels(类似于IO中的Stream)   可以从Buffers中读数据，也可以写数据到Buffers
FileChannel
DatagramChannel
SocketChannel
ServerSocketChann

int bytesWritten = inChannel.write(buf);  
int bytesRead = inChannel.read(buf);

b) Buffers 有三个属性：capacity、position、limit
ByteBuffer
CharBuffer
DoubleBuffer
FloatBuffer
IntBuffer
LongBuffer
ShortBuffer

c)Selector（运行单线程处理多个channel）
 要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。


负载均衡的简单实现
存在一个IpMap 存放ip和对应的权重
 serverWeightMap.put("192.168.1.100", 1);
 serverWeightMap.put("192.168.1.101", 2);

1)轮询
   重建一个Map，避免服务器的上下线导致的并发问题
   serverMap=serverWeightMap;
   //获取IP地址List
   Set<String> keySet = serverMap.keySet();
   //定义一个Ip地址最终轮询的List
   ArrayList<String> keyList = new ArrayList<String>();

   Iterator<String> iterator = keySet.iterator();
  //根据权重组装List
   while(iterator.hasNext()){
​       String service = iterator.next();
​       Integer weight = serverMap.get(service);
​       for(int i=0;i<weight;i++){
​          keyList.add(service); 
​       }
   }

     //轮询取出目标IP地址
     String server = null;
        synchronized (pos)
        {
            if (pos > keySet.size())
                pos = 0;
            server = keyList.get(pos);
            pos ++;
        }
   return server;


   其他方法：随机（Random）法、源地址哈希（Hash）法


jvm内存区域划分
程序计数器     如果当前线程执行的是非native方法，程序计数器保存的是当前执行的指令地址，如果是native方法则程序计数器中的值是undefined
java栈         存储局部变量，如果变量是基本类型存储值如果变量是引用类型存储引用
本地方法栈     和jvm栈所发挥的作用类似，区别是jvm栈为jvm执行java方法（字节码）服务，而本地方法栈为jvm使用的native方法服务。
方法区         用于被虚拟机加载的类信息，常量、静态变量
堆             存放对象实列
堆是有序完全二叉树，图形的树状结构，，栈是一种先进后出的线性表



线程池ThreadPoolExecutor、
ThreadPoolExecutor继承AbstractExecutorService
AbstractExecutorService 实现 ExecutorService 接口
ExecutorService 继承 Executor接口
execute()      通过这个方法向线程池提交一个任务，交由线程池执行。
submit()       也是向线程池提交任务，但是可以返回执行结果(利用了Feture来获取执行结果)
shutdown()     关闭线程
shutdownNow()  关闭线程

*****项目难点*****

印象比较深刻的线上bug

HashMap 1.8相比于之前好在哪里

并发环境下还会使用hashTable吗(concurrenHashMap)
并发环境下使用hashMap可能会导致程序死循环，使用线程安全的hashTable效率太低
concurrentHashMap采用分段锁的技术有效的提高并发的访问率：将数据分段，每一段数据分配一把锁，当一个线程访问某一段数据的时候，其他段的数据可以被访问
由segement数组和hashEntry数组结构组成
segement：可重入锁
hashEntry:存储键值数据

ConcurrentHashmap通过分段锁技术提高了并发的性能，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。另外concurrenthashmap的get操作没有锁，是通过volatile关键字保证数据的内存可见性。所以性能提高很多。JDK8对ConcurrentHashmap也有了巨大的的升级，同样底层引入了红黑树，并且摒弃segment方式，采用新的CAS算法思路去实现线程安全，再次把ConcurrentHashmap的性能提升了一个台阶。




如果fullGc比较频繁怎么处理

Spring 使用注解方式进行事务管理
使用步骤：
1)spring配置文件中引入tx命名空间
2)具有@Transactional 注解的bean配置为声明式事务支持
3)可以在接口、类、方法加@Transactional使用事务

Spring配置文件中关于事务配置总是由三个组成部分，
分别是DataSource、TransactionManager和代理机制这三部分



线程池的作用
减少线程创建、销毁的次数，工作线程可以使用多次
可以根据系统情况调整执行线程的数量，防止消耗过多内存


#Redis最为常用的数据类型主要有以下：
String
Hash   Value是hashMap
List
Set
Sorted set
pub/sub
Transactions

mysql性能调优
1.最基本的调优是使表在磁盘中占的空间尽可能的小，在更小的列上做索引也会占更少的资源
​    a) 使用正确合适的类型，不要将数字存储为字符串。
​    b) 尽可能地使用最有效(最小)的数据类型。MySQL有很多节省磁盘空间和内存的专业化类型。
​    c) 尽可能使用较小的整数类型使表更小。例如，MEDIUMINT经常比INT好一些，因为MEDIUMINT列使用的空间要少25%。
​    d) 如果可能，声明列为NOT NULL。它使任何事情更快而且每列可以节省一位。注意如果在应用程序中确实需要NULL，应该毫无疑问使用它，只是避免 默认地在所有列上有它。

2.索引
​    a) MySQL只会使用前缀，例如key(a, b) …where b=5 将使用不到索引。    
​    b) 要选择性的使用索引。在变化很少的列上使用索引并不是很好，例如性别列。
​    c) 避免重复索引
​    d) 在查询中要使用到索引（使用explain查看），可以减少读磁盘的次数，加速读取数据
​    e) 相近的键值比随机好。Auto_increment就比uuid好。
​    f) 不要在表达式上运算、索引列不能是表达式的一部分也不能是函数的参数
​    g）应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。可以用not exists或者（外联结+判断为空）来代替
​    h）用 or 分割开的条件， 如果 or 前的条件中的列有索引， 而后面的列中没有索引， 那么涉及到的索引都不会被用到。
​    i）组合索引的使用要遵守“最左前缀”原则'
​    j) 如果是null不会走索引
https://www.cnblogs.com/beijingstruggle/p/5885137.html

索引原理分析
索引：是帮助mysql高效获取数据的一种数据结构。
mysql最基本获取数据的方式是顺序查找时间复杂度是O(n)，如果数据量很大的情况下，查询的效率就很低，优化查询方法有二分查找、二叉树查找，但是通过这种方法查找需要数据满足某种数据结构：二分查找需要数据有序、二叉树查找需要应用于二叉树上，但是数据本身无法满足特定的数据结构，所以在数据库系统还需要维护一种特定的数据结构，这些数据结构以某种方式指向数据，这样可以通过特定的算法提高查询效率。

数据库三范式
1、字段不可分割：不可建立复合字段
2、主键依赖：数据库中所有字段必须和主键有关
3、不能存储相同的信息：一个对象里不能引用另外一个对象，存储一个引用就好

##### 分布式锁(保证分布式多线程情况下一个代码块只能有一个线程访问)

* Memcahed分布式锁

  利用Memcached的**add命令**。此命令是原子性操作，只有在key不存在的情况下，才能add成功，也就意味着线程得到了锁。

* Redis分布式锁

* Zookeeper分布式锁

  利用Zookeeper的**顺序临时节点**，来实现分布式锁和等待队列。Zookeeper设计的初衷，就是为了实现分布式锁服务的

解决在分布式系统中实现，不同线程对于代码、资源的同步访问的问题
**一、通过redis实现布式锁**

* 加锁：通过setnx，按照逻辑组装的key存入,当线程执行返回1则说明原本key不存在，该线程获得锁，如果返回0则说明该线程获取锁失败。
* 2.解锁：线程执行完必须要有解锁，方便其他线程继续执行
* 3.锁超时，如果某线程得到锁之后挂掉了，这块资源会被一直锁住，别的线程无法获取锁，所以必须设置一个超时时间，自动释放锁
  伪代码
  ​

```java
 if(setnx(key,1)==1){
      expire(key,5);
       try{
         do something
       }finally{
         del(key)
       }
    }
```



**问题**：
1、setnx、expire非原子操作、如果setnx成功了但是程序挂掉了会出问题
Redis 新版本中出现set(key,1,30,NX) 原子操作
2、误删：如果线程1设置了30s，30s没有执行完，线程2进入，然后线程1执行完了，把线程2的锁del了
解决误删有两个方法： a)把线程id作为Value，删除之前比较一下value
​                                        b)增加一个守护线程，在快超时的时候增加过期时间

**二、使用数据库乐观锁**
确定：分布式情况下，数据库性能一般是瓶颈。

守护线程
Gc是一个典型的守护线程

索引的原理：
​    索引是对记录集的多个字段进行排序的方法。在一张表中为一个字段创建一个索引，将创建另外一个数据结构，包含字段数值以及指向相关记录的指针，然后对这个索引结 构进行排序，允许在该数据上进行二分法排序。

    副作用是索引需要额外的磁盘空间，对于MyISAM引擎而言，这些索引是被统一保存在一张表中的，这个文件将很快到达底层文件系统所能够支持的大小限制，如果很多字段都建立了索引的话。

mysql优化
1、优化sql和索引
2、加缓存redis、memacached
3、用mysql自带的分区
4、读写分离：
数据同步：    
​    Mysql，它自己有一个master-slave功能，可以实现主从数据库的自动同步。
路由规则：
a)使用编码的方式，在DAO层区分读写方法，分别调用不同数据库。    
b）使用中间件
5、垂直拆分
6、水平拆分



redis、menacached缓存的比较
1、由于Redis只使用单核，而Memcached可以使用多核，存储小数据是redis比较快，在100k以上的数据中memacached性能更高。
2、对于key-value这样简单的数据储存，memcache的内存使用率更高。如果采用hash结构，redis的内存使用率会更高
3、如果从数据持久化或者数据排序过期处理的角度考虑推荐使用redis（快照和AOF），mamecache数据全部存储在内存中，宕机后数据会丢失。
4、数据类型上redis比memecach多
5、 对于两者的选择还是要看具体的应用场景，如果需要缓存的数据只是key-value这样简单的结构时，我在项目里还是采用memcache，它也足够的稳定可靠。如果涉及到存储，排序等一系列复杂的操作时，毫无疑问选择redis。


失效转移有三部分组成：失效确认、访问转移、数据恢复

缓存击穿
1）大量使用不存在的key进行高并发查询，导致缓存无法命中，每次请求到会击穿到后台数据库中查询，使数据库压力过大被压死；
解决方法：将空值缓存起来，查询的时候如果没有缓存直接返回。对参数进行校验不符合规则直接返回
2）key过期问题；
解决方法：使用分布式锁，每次只能有一个线程。避免了高并发。如果是服务器重启导致的key失效，可以通过测试预热，生成缓存。


​    




https://blog.csdn.net/evankaka/article/details/70570200

订单系统设计
数据模型依赖于具体的业务场景，也就是应用场景中有哪些操作
针对订单有如下操作：
创建、修改、查询，取消订单 订单配送、评价等功能
所以这里可以创建：订单表、订单详情表、订单配送表



设计模式中的代理模式
分布式锁
为甚么redis适合做分布式锁
为什么使用索引会加快查询效率
redis如何实现原子性
事物的一致性怎么解释
一致性是对数据可见性的约束，保证一个事物中多个操作数据的中间状态对于其他事物是不可见的，这些中间状态是过度状态与事务的开始状态和结束状态是不一致的。

spring加载servelet的过程
项目中遇到的问题怎么解决的

SpringMVC的拦截器（Interceptor）和过滤器（Filter）的区别与联系
过滤器: 依赖serlet容器。在实现上基于函数回调，只在web启动的时候初始化一次
拦截器：依赖于web框架，在springMvc中基于依赖于springMvc框架，基于java反射实现的，属于AOP的一种运用。
https://www.zifangsky.cn/700.html

servelet的理解
servelet就是一个接口，包含init、getServeletConfig、service、getServeletInfo、destrory五个方法。
该接口的作用是定义了处理网络请求的规范

java基础
static、final、transient、volatile这一类的关键字，以及内部类、泛型这一类的高阶语法
jvm
并发知识与concurrent包
设计模式和反射
文件IO、NIO、网络IO以及网络协议

进阶
Spring、Mybatis框架
数据库优化
Linux服务器

在并发编程中有三个概念：
原子性：在单线程的情况下很多操作可以看成是原子性，如i+1，在多线程的情况在则不同，在多线程下保证原子性一般通过锁来确保。
可见性：java通过volatile保证可见性
有序性：java内存模型中为了效率允许编译器和处理器进行指令重排，指令重排不会影响单线程的运行结果，但是多线程会影响，Java提供volatile来保证一定的可见性、有序性。

volatile：加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：
1、禁止指令重排
2、如果是写操作会导致，其他cpu中的缓存无效
3、强制将缓存的修改操作立即写入主存

编译器重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；
处理器重排序。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序；



天猫消费积分发票处理与OCR对接
TP(支付)根据发票账单汇总生成开票通知单,TP将月账单同步到TAX(税务)，
税务将月账单展示在账房，商家通过账房勾选月账单生成开票通知单，线下邮寄发票
TAX收到发票，OCR扫描录入发票，系统将发票进行核销

稽核工具
用于业务对账，业务方产生交易数据，交易数据可能存在不平情况，如果通过人工排除不平数据需要重复写很多sql
所以需要一个类似于模板的工具，只需要配置几个核心的字段(如：核对值、核对关联条件、表名)，其他东西可以通过程序自动化完成。
针对这个需求就有了稽核工具的产生。

产生背景：当你的业务线很长、而且业务线是建立在分布式的基础之上的，在某个环节双方之间的交互就会出现问题，例如用户在天猫上买一件商品，用支付宝付款，那么就会产生一条交易记录和一个支付宝流水，整个交易的链路很长而且相当的复杂，那么就需要保证双方数据的准确性、和异常的监控，那么稽核这个产品就出现了
在你看来可能很简单：它的稽核方式其实是有很多种的：
双数据源：
例如结算系统记账，生成记账单的同时会通知财务系统生成对账单，结算系统的记账单和财务系统的对账单之间的稽核。双向数据源按照稽核方式可以分为以下两种
​    单项稽核：以某一方数据为准，一般由A数据生成B数据额，系统内部场景，在比对的时候是以A数据为准，类似SQL中的left join
​        例如，财务系统的开票通知单通知商家邮寄发票，所有的发票均是由开票通知单产生，其中开票通知单和发票的稽核，应该以开票通知单的数据为基准。
​    双项稽核：以数据双方为准，一般是跨系统的场景，
​        业务系统的订单付款在支付宝中生成支付宝流水，针对订单和支付宝流水的稽核，作为订单系统的维护同学，不能完全信赖支付宝的流水数据，例如支付宝当天的数据离线同步到云梯出问题了，也会影响稽核结果，所以需要以订单和支付宝流水同时作为标准进行比对。

亮点：
a.稳点:上线以来，一直稳定的运行,目前除了在汇金部门内部使用，也被引入其他事业部使用(天猫国际、阿里云、天猫超市)
b.使用方便：配置过程很简单，即使是一个小白过来也可以很快的上手，配置属于自己的全链路稽核
c.如果你的系统上线初期可以通过稽核工具判断系统是否出问题，定位问题所在
d.对于业务数据的走势有很清晰的了解，例如在上述提到的比对账单和发票的稽核中，可以监控点到有很多发票未及时回票的情况，并针对这种情况，做出针对性的策略，来保证用户的回票率。
e.它像是一个模型，意义在于省去扔手动排除数据问题。


稽核产品是一个基于汇金事业部业务出账，开发的一个数据对比的产品，使用场景，在天猫上买一件商品通过支付宝付款，下单和付款这两个动作，长的交易链路在分布式的环境下，应用和应用的交互可能出现问题，出现不平数据，基于这个需求开发了稽核产品。
主要划分为一下几个模块：
a) 业务配置  相当于不同的模块
b）任务配置  配置取目标数据的sql、和数据比对的sql
c）运行实例  读取配置，更具配置的sql，在云梯上取目标数据、把取出来的数据更具配置的规则比对。
​      汇总实例 普通实例运行完会有汇总
d）不平展示



​     



主要的实现原理：
业务配置(手动接入新的业务)
​      |
​      |手动配置
​      |
​      稽核任务配置(配置出数据收集的sql，也就是需要把需要对账的捞出来的sql)
​      |
​      |定时任务调度
​      |
​      a)通过稽核任务生成实列(将稽核任务run起来,拿到数据收集的sql,取出需要对账单数据，把数据放到稽核的数据集收集的表中,两方的数据分别放到不同的分区中，
​      b)在通过后台组装的一个sql把收集到的数据join 并且算出'核对值的差异' 后放到稽核的数据汇总的表中) 到这一步 就相当于比对出了不平的数据。
​      c)通过count语句统计出稽核结果
​      |
​      |同步调用、异步调用、接口幂等
​      |
​      稽核实列跑完后会生成汇总实列
​      |
​      |
​      数据修复、人工处理过、如果业务方处理则需要调用第三方接口(交易没有账单金额, 
​       但是有支付宝金额的情况 进行重试销账，销账成功则自动处理完成,无需人工再跟进))
​       路由第三方接口规则:通过checkType创建一个consumerBean，在配置项中配置业务类型和接口的关系，第三方应用根据关系提供HSF接口
​       --当时遇到一个问题springBean加载顺序问题 通过depend-on解决
​      |
​      |
​      数据修复(人工排查定位问题)

    最终稽核汇总
    a)将单个普通实例汇总的不平数据进入沉淀池:allcheck_diff_hidden
    
    b)沉淀池合并 放到 allcheck_diff_hidden_history_temp(每天合并一次,历史沉淀池(allcheck_diff_hidden_history)和沉淀池数据合并allcheck_diff_hidden)
    
    c)对已经完成作废的稽核数据进行排除清理 放入:allcheck_diff_hidden_history_cancel
    
    d)将从沉淀中期中和掉的数据放入一个独立的抵充分区，供后期排查问题 比如 9月1日 A01 订单source不平 100，9月2日 A01 订单target不平 100. 那么认为该数据是平衡的,将两条数据移动到takeout分区: allcheck_diff_hidden_history_takeout
    (查询allcheck_diff_hidden_history_temp 的数据通过checkType、outBizId分组如果sum(baseAmount)=0 且count(1)=2 那么任务数据平的)


    e)将修复过的数据忽略掉 allcheck_diff_hidden_history_takeout_deal
      关联同步到云梯上的check_result_opreation中数据判断
    
    f)获取最新数据 allcheck_diff_hidden_history 
      从allcheck_diff_hidden_history_temp查询数据排除allcheck_diff_hidden_history_cancel
    、allcheck_diff_hidden_history_takeout、allcheck_diff_hidden_history_takeout_deal







不能盲目的投简历，更不能盲目的面试，应该通过每一次面试发现自己的软肋，不断强化自己！！！



本来 session 是一个抽象概念，开发者为了实现中断和继续等操作，将 客户端和服务器之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 session 的概念。 而 cookie 是一个实际存在的东西，http 协议中定义在 header 中的字段。可以认为是 session 的一种后端无状态实现。而我们今天常说的 “session”，是为了绕开 cookie 的各种限制，通常借助 cookie 本身和后端存储实现的，一种更高级的会话状态实现。所以 cookie 和 session，你可以认为是同一层次的概念，也可以认为是不同层次的概念。具体到实现，session 因为 session id 的存在，通常要借助 cookie 实现，但这并非必要，只能说是通用性较好的一种实现方案。

1，session 在服务器端，cookie 在客户端（浏览器）
2，session 默认被存在在服务器的一个文件里（不是内存）
3，session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）
4，session 可以放在 文件、数据库、或内存中都可以。
5，用户验证这种场合一般会用 session






反射：
通过反射可以在运行时获取程序或程序集中每一个类型的成员和成员的信息

sql优化
mysql本身存在缓存，缓存默认开启，缓存存在一个引用表中(类似于hashMap)，缓存在表结构变化、有写操作时会失效
1.任何的查询语句在开始之前都必须经过检查，即使这条SQL语句永远不会命中缓存
2.如果查询结果可以被缓存，那么执行完成后，会将结果存入缓存，也会带来额外的系统消耗

所以并不是缓存一定可以带来性能的提升，缓存和失效都会带来性额外损耗，所以只有当缓存资源节约大于本身的消耗时才能有性能的提升，但是这个评估很难
如果系统确实存在一些性能问题，可以尝试打开查询缓存，并在数据库设计上做一些优化，比如：
1、小表代替大表
2、批量插入代替循环插入
3、合理的控制缓存的大小
4、可以通过SQL_CACHE和SQL_NO_CACHE来控制某个查询语句是否需要进行缓存

mysql的而执行过程
客户端向MySQL服务器发送一条查询请求
服务器首先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段
服务器进行SQL解析、预处理、再由优化器生成对应的执行计划
MySQL根据执行计划，调用存储引擎的API来执行查询
将结果返回给客户端，同时缓存查询结果

优化策略
1、数据类型遵循小而简单的原则(整性比字符串代价低、时间用dateTime代替字符串)
2、如果列需要增加索引 需要not null
3、通常一个组合索引优于多个独立的索引(更具具体的sql定)
4、select * 需要先识别字段再进行查询


java高并发、分布式缓存


redis的使用场景
签到：使用redis中的set，签到是将数据zadd到redis中，将时间作为权重，工号作为value
可以使用shardedJedis.zrange("zset", 0, -1))对数据进行排序，shardedJedis.zcount("zset", 1.0, 5.0))统计权重在某个范围的数据

抢购的场景
痛点：为了保证系统的响应效率，和并发情况下数据的准确性
redis String数据结构 的incr(xx)，decr(key),将key为xx的valkue原子加一、减一操作，可以在秒杀、抢购的场景下降商品作为key，数量作为value，然后进行临界值判断，若超出，则提醒用户，并进行自减操作。
如果是已经生成好的数据，可以使用List的lpop，逐个删除


redis中的String数据结构，setNx操作可以在新增键值对时防止覆盖原先值，在抢购的场景下，将userid作为key，商品id作为value,这个原子操作可以阻止用户重复提交
redis中List数据结构，为了缓解短时间大批量的请求数据库，可以采用指令牌机制解决，通过redis模拟一个指令牌在内存中，用户请求过来，到内存中获取令牌，先到先得，没拿到的回绝。


数据模型设计
秒杀记录表
records_id      
good_code   商品标识
user_id     用户标识

秒杀商品表
good_code        商品id   
good_count       余量



1.分布式服务，资源数据存放位置唯一，可在该方面寻求解决方法

  数据库的唯一索引、强检验、id自增、乐观锁，redis的原子操作等

2.分布式服务，可通过方案设计将并发访问变成串行访问，很好的避免并发



java内存模型中围绕着
原子性：基本数据类型的读写是由原子性的，Long、double例外。lock、synchronize
可见性：volatile保证了多线程操作时变量的可见性。synchronize和final，同步代码块对一个变量执行unlock操作之前必须同步主存，final变量一旦初始换完成(且构造器没有把this的引用传递出去)其他线程就可以看到final字段。
有序性：volatile禁止指令重排，synchronize一个变量在某一时刻只允许一个线程访问

final
修饰类、方法、变量（包括成员变量和局部变量）
1.修饰类
当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。

2.修饰方法
“使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。“
　　因此，如果只有在想明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的。
​    注：类的private方法会隐式地被指定为final方法。

3.修饰变量
　修饰变量是final用得最多的地方，首先了解一下final变量的基本语法：
  对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。    


Java中的String类就是一个final，类String不可变很简单，如给一个已有字符串"abcd"第二次赋值成"abcedl"，不是在原内存地址上修改数据，而是重新指向一个新对象，新地址。String被称为不可变类型，StringBuild和StringBuffer为可变类型



String 不可变的好处在于
1）安全：对于一个字符串多个方法修改，每个方法之间互不影响，如果用可变类型存入HashSet中就破坏了HashSet键值的唯一性。所以千万不要用可变类型做HashMap、HashSet键值。
2）不可变性支持线程安全：就是在并发场景下，多个线程同时读一个资源，是不会引发竟态条件的。只有对资源做写操作才有危险。不可变对象不能被写，所以线程安全。
3）不可变性支持字符串常量池：String另外一个字符串常量池的属性。像下面这样字符串one和two都用字面量"something"赋值。它们其实都指向同一个内存地址。在大量使用字符串的情况下，可以节省内存空间，提高效率



线上问题排查：
jstack
通过ps、jps找出processId，可以通过jstack -l <pid> > stack_<pid>.log，将线程栈信息打印到文件中，查看线程的执行情况。
遇到应用进程占用cpu较多，可以通过top -p pid-H获取到是哪个线程消耗cpu较多，然后将线程id转换成十六进制，从线程栈文件找出对应的线程正在做什么，排查死锁问题，则直接查找线程栈文件，基本可以找出来大部分的死锁的问题。

jmap
通过jmap可以打印出jvm堆中对象的数量及引用关系，在dump堆之后可以通过MAT或者HA分析出哪个对象实例占用较多，是否有内存泄露的情况。
常用的用法有：
jmap -histo:live <pid>，这种用法会强制执行一次fgc；
jmap -heap <pid>，直接打印出各对象实例的分布情况；
jmap -dump:[live],format=b,file=dump.bin <pid>，将heap dump到指定文件中
jmap -heap pid  
展示堆的完整信息

jstat
jstat在排查gc问题时真的很好用，它能够提供一些统计信息，包括gc次数，gc原因，内存占用等。还是先来看一下jstat的用法吧：
比较常用的用法有：
jstat -gcutil <pid> [interval]，每隔interval（ms）打印出进程pid的gc情况；
jstat -gccause <pid> [interval]，对于gcutil选项，该选项会将gc的原因列出来；

jinfo
jinfo主要用来查询jvm进程的运行时的jvm参数，以及修改jvm运行时的参数，
主要用法如下：
jinfo -flag <name> <pid>，查询进程pid name的参数值；
jinfo -flag <name>=<value> <pid>，设置jvm参数name的值为value；
jinfo -flag [+|-]<name>,启用某个参数或禁用某个参数。



线上oom 解决
临时方案就是重启

一般方法
a）dump内存
使用jmap命令dump内存，也可以加参数-XX:+HeapDumpOnOutOfMemeryError，在OOM的时候自动dump内存，

b）看一下GC日志
如果没有任何JVM参数设置，gc日志默认打印在stdout.log文件里，里面可能会打其他的日志，而且GC日志也不会输出时间，所以在JVM启动参数里最好加以下命令，规范下GC日志输出到/home/admin/logs/gc.log，并且打印GC时间。
-XX:HeapDumpPath=/home/admin/logs -Xloggc:/home/admin/logs/gc.log  -XX:+PrintGCDetails -XX:+PrintGCDateStampsses



Webx Framework将一个WEB应用分解成多个小应用模块：app1、app2，当然名字可以任意取。
每个小应用模块独享一个Spring Sub Context子容器。两个子容器之间的beans无法互相注入。
所有小应用模块共享一个Spring Root Context根容器。根容器中的bean可被注入到子容器的bean中；反之不可以。将一个大的应用分解成若干个小应用模块，并使它们的配置文件相对独立，这是一种很不错的开发实践。




springMvc 
角色：控制器、验证器、模型对象、Servlet分发器、处理映射器、视图解析器

session和cookie的区别
1，session 在服务器端，cookie 在客户端（浏览器）
2，session 默认被存在在服务器的一个文件里（不是内存）
3，session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）
4，session 可以放在 文件、数据库、或内存中都可以。
5，用户验证这种场合一般会用 session

sleep和wait的区别
1、sleep是Thread的方法wait是Object的方法
2、wait必须要在同步方法或同步方法块中使用、sleep没有限制
3、wait会释放占有的对象锁，使得线程可以进入线程池等待下一次获取资源，而sleep只会让出cpu并没有释放锁
4、sleep到达休眠时间会再次获取cpu再次执行吗，而wait必须等待notify通知

yield和sleep
二者都会让出cpu，但是yield让出后只有优先级一样的线程可以获取资源

1、如何实现阻塞队列
2、redis中的SortedSet如何实现有序的
3、dubbo如何实现负载均衡的
4、如何设计一个注册中心
5、调用方缓存的什么信息到本地
6、hash索引和B-tree索引的使用场景
7、聚集索引、非聚集索引的区别


session和cookie的区别
http请求的头
事物嵌套问题
springBoot和传统的架构的区别
反向代理、正向代理
两个方法，通过异步调用提高效率
static能不能声明为事物



* countDownLatch：允许一个或多个线程等待某些操心完成

* CyclicBarrier：一种辅助性的同步结构，允许多个线程等待到达某个屏障

* Semaphore：Java版本的信号量实现。

  countDownLatch和CyclicBarrier的区别：前者是不可重置的，所以无法重用；而后者没有这种限制，可以重用。

* CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：
  CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；
  而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；
  另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。
  2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。



常见的runtime exception

* ClassCastException类型强制转换异常
* NullPointerException空指针异常类
* NoSuchMethodException 方法未找到异常
* ArrayIndexOutOfBoundsException数组下标越界异常
* ClassNotFoundException找不到类异常





**CountDownLatch**

java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了



**CyclicBarrirer**

字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。



#### servlet

* 当第一次调用某个servlet容器时，需要在入其servlet类，并调用其init方法
* 针对每一个request请求，创建一个javax.servlet.ServletRequest、javax.servlet.ServletResponse实例
* 调用servlet的service方法，将servletRequest、ServletResponse作为参数载入
* 当关闭servlet类时，调用其destory方法，并卸载servlet类

 

tomcat将错误信息存储在一个properties文件中，便于读取和编辑。tomcat将properties文件划分到不同的包中，每个文件都是通过StringManager类来处理的











